# [AFL - American Fuzzy Lop](http://lcamtuf.coredump.cx/afl/)
American fuzzy lop is a security-oriented [fuzzer](https://en.wikipedia.org/wiki/Fuzzing) that employs a novel type of compile-time instrumentation and genetic algorithms to automatically discover clean, interesting test cases that trigger new internal states in the targeted binary. The genetic algorithms aim to efficiently increase code coverage of the test cases. It helps with testing software to find unexpected results within applications.    afl is written in C.

**Testing Approach:** Fuzz testing
**Testing Level:** Application testing
**Target application domain:** Application testing

## Features
* Fuzzing engine: The fuzzing engine of american fuzzy lop uses several algorithms whose goal is to trigger unexpected behavior, including bit flips or replacing bytes of input file with various integers that can trigger edge cases.[13] Apart from that, it can generate test cases based on sample keywords, which helps during fuzzing of programs that employed text-based grammar, such as SQLite. Generated test cases that exercise different parts of the program's code can later be used as input for more specialized diagnostic programs. While performing the fuzzing, a hang can be detected when the process does not exit within the specified timeout and crash is assumed when a signal handler kills the process.

The fuzzed input can be fed to the tested program either via standard input or as an input file specified in the process command line. Fuzzing networked programs is currently not directly supported, although in some cases there are feasible solutions to this problem.

* Performance: One of the challenges american fuzzy lop had to solve involved an efficient spawning of hundreds of processes per second. Apart from the original engine that spawned every process from scratch, american fuzzy lop offers the default engine that relies heavily on fork system call. This can further be sped up by leveraging LLVM deferred forkserver mode, but this comes at the cost of having to modify the tested program. Also, american fuzzy lop supports fuzzing the same program over the network.
* User Interface: american fuzzy lop features a colorful command line interface that displays real-time statistics about the fuzzing process. Various settings may be triggered by either command line options or environment variables. Apart from that, programs may read runtime statistics from files in a machine-readable format.
* Utility programs: In addition to afl-fuzz and tools that can be used for binary instrumentation, american fuzzy lop features utility programs meant for monitoring of the fuzzing process. Apart from that, there is afl-cmin and afl-tmin, which can be used for test case and test corpus minimization. This can be useful when the test cases generated by afl-fuzz would be used by other fuzzers.

## Pros
* designed to be practical
* it has modest performance overhead
* uses a variety of highly effective fuzzing strategies and effort minimization tricks
* real-world use cases 
* It is pretty sophisticated
* It has street smarts
* It is fast
* It's rock solid
* No tinkering required
* It's chainable to other tools
* It sports a hip, retro-style UI


## Cons
* only linux ?

## Required information / models
The program requires the user to provide a sample command that runs the tested application and at least one small example input file. 

After this initial phase, AFL begins the actual process of fuzzing by applying various modifications to the input file. When the tested program crashes or hangs, this might suggest the discovery of a new bug, possibly a security vulnerability. In this case, the modified input file is saved for further user inspection.

In order to maximize the fuzzing performance, american fuzzy lop expects the tested program to be compiled with the aid of a utility program that instruments the code with helper functions which track control flow. This allows the fuzzer to detect when the target's behavior changes in response to the input. In cases when this is not possible, black-box testing is supported as well.

Afl is known to work on Linux.

## Target platform and dependencies
(Add: Description of the target platform, language, and/or environment that the tool assumes or targets.)

**Dependencies:** 
*Linux machine
*Basic C and command line experience

## Updates
(Add: A sentence or two about how well the tool is updated/maintained)

**Latest update:** (Add date for latest update of the tool)
**First release date:** (Add date for first commit or release of the tool)

## Licensing / Cost
Apache License 2.0 / Free

## Tutorials and documentation
*Tutorial: There is an afl-training available [here](https://github.com/ThalesIgnite/afl-training). The specific training contains extra material like presentation, video, link for afl-users mailing list, link for workshop and tutorial.
*Documentation: The official documentation is available [here](http://lcamtuf.coredump.cx/afl/QuickStartGuide.txt)

## Usage examples
(Add: A few descriptions of how the tool has been used, ideally linking to libraries or software that actively is using the tool. Here you will also link to your "use case".)

## Alternative tools
* [0d1n](https://github.com/CoolerVoid/0d1n/)
* [Granota](https://github.com/valldrac/granota)
* [boofuzz](https://github.com/jtpereyda/boofuzz)
* [dirsearch](https://github.com/maurosoria/dirsearch)
